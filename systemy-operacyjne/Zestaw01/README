    Zestaw 1 code{white-space: pre-wrap;} span.smallcaps{font-variant: small-caps;} span.underline{text-decoration: underline;} div.column{display: inline-block; vertical-align: top; width: 50%;} div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;} ul.task-list{list-style: none;} .display.math{display: block; text-align: center; margin: 0.5rem auto;}  

Zestaw 1
========

Procesy

Termin 23.03.2021 - 20.04.2021

Proszę zapoznać się ze [**wstępem do programu _make_**](https://ujchmura.sharepoint.com/:u:/r/teams/Systemyoperacyjnewiczenia/Materiay/IntroMake.html?web=1) oraz [**skryptem**](Procesy.pdf), który zawiera wszystkie informacje potrzebne do rozwiązania tego zestawu. Napisać odpowiedni plik `Makefile` oraz `README` dotyczący wszystkich programów w tym zestawie. Zadania należy umieścić w katalogu `Zestaw01`, a programy powinny mieć _sensowne_ nazwy. **Nie** tworzyć osobnych katalogów dla każdego zadania. Nazwy plików wykonywalnych powinny posiadać rozszerzenie `.x`.

Zadania należy oddać w trakcie ćwiczeń w terminie oddania, każdy tydzień zwłoki powoduje obniżenie oceny o pół stopnia. Zadanie można oddawać nie najpóźniej niż w terminie ostatecznym, wówczas trzeba rozwiązać także ćwiczenia dodatkowe. Brak zaliczenia zestawu w terminie ostatecznym oznacza **brak zaliczenia** całych **ćwiczeń**.

### Zadanie 0. Start

Proszę zapoznać się ze wzorcowym katalogiem z programami w języku C:

1.  Pobrać i zapisać w swoim katalogu ćwiczeniowym plik [StartSO.tar.gz](StartSO.tar.gz)
2.  Rozpakować: `tar xvzf StartSO.tar.gz`
3.  Przejść do katalogu `StartSO`, przeczytać plik `README` i wykonać zawarte tam polecenia.
4.  Przyjrzeć się programom, głównie plikowi `hello.c`.
5.  Przeanalizować plik `Makefile`, głównie odnośnie programu pierwszego, czyli `hello`.

### Zadanie 1. Procinfo

Na rozwiązanie zadania składają się następujące pliki: `Makefile`, `main.c`, `procinfo.c` i `procinfo.h`.

Plik `Makefile`:

*   Proszę zapoznać się ze [Wstępem do make](IntroMake.html).
*   Bazując na wstępie (nie przerabiać pliku `Makefile` z pakietu `StarSO`) napisać od zera minimalny plik `Makefile` zawierający zależności dla _celów_ `main.o`, `procinfo.o` i `main.x` oraz regułę wzorcową `%.o` → `%.x`.
*   Utworzyć regułę domyślną (pierwszą) **all**, która zależy tylko od `main.x` i regułę **clean**, która usuwa pliki tymczasowe i wykonywalne, użyć dyrektywy **.PHONY**.

Plik `procinfo.c`:

*   Zawiera **definicję** (implementację) funkcji `int procinfo(const char* name)`, która wypisuje identyfikatory `UID, GID, PID, PPID` i `PGID` dla aktualnego procesu oraz nazwę programu przekazaną jako argument.
*   Plik źródłowy ma zawierać tylko tę funkcję, nie ma zawierać funkcji `main`.

> **Uwaga:** Funkcja `procinfo` powinna wypisywać wszystkie informacje w jednej linii.  
> Zapobiegnie to _przeplataniu_ wiadomości pochodzących od kilku procesów działających jednocześnie.  
> Należy wyświetlać także nazwy identyfikatorów, a nie same liczby, np.  
> `Name = ./procesy.x, UID = 1000, GID = 1000, PID = 112, PPID = 111, PGID = 110`

Plik nagłówkowy `procinfo.h`:

*   Zawiera deklarację funkcji `procinfo`.
*   Należy zastosować dyrektywy preprocesora, które zapobiegną wielokrotnemu dołączaniu tego samego pliku nagłówkowego. Patrz plik `funkcja.h` w pakiecie `StartSO`.

Plik `main.c`:

*   Zawiera implementację funkcji `int main(int argc, char* argv[])`, która jedynie wywołuje funkcję `procinfo` z argumentem będącym nazwą programu (`argv[0]`).

### Zadanie 2. Kopiowanie

Napisać program `kopiuj.c`, który kopiuje zawartość jednego pliku do drugiego. Nazwy plików są podane w linii komend, nazwa pliku źródłowego znajduje się w `argv[1]`, a docelowego w `argv[2]`. W przypadku złej liczby argumentów (`argc`) wypisać komunikat o prawidłowym użyciu programu (użyć aktualnej nazwy programu, `argv[0]`).

*   Użyć funkcje systemowe `open`, `read`, `write`.
*   Obsłużyć wszystkie możliwe błędy wywołań funkcji systemowych i bibliotecznych, użyć funkcji `perror`.

> **Wskazówka:** Należy stworzyć bufor (tablica typu `char`) o zadanym rozmiarze (np. 1024 bajtów) i w pętli wczytać zawartość pliku do bufor (nie przepełniając go) i zapisywać do pliku docelowego **odczytaną** liczbę bajtów. Pamięć pod bufor można zaalokować statycznie bądź dynamicznie używając `malloc()`, wówczas należy pamiętać aby ją zwolnić wywołując `free()`.

### Zadanie 3. Procesy

Napisać program `procesy.c`, który wykonuje następujące zadania:

*   Przy użyciu funkcji `procinfo()` z poprzedniego zadania,wypisać identyfikatory `UID`, `GID`, `PID`, `PPID` i `PGID` dla danego procesu
*   Wywołać funkcję `fork()` 3 razy w pętli `for` lub `do {...} while()` i wypisać powyższe identyfikatory dla wszystkich procesów potomnych. Sposób użycia funkcji `fork` jest opisany w **skrypcie**.
*   Wstawić funkcję `sleep()` w takich miejscach programu, aby procesy pojawiały się na ekranie grupowane pokoleniami od najstarszego do najmłodszego.
*   Procesy powinny czekać na wszystkie swoje procesy potomne używając funkcji `wait()`.  
    
*   Na podstawie wyników programu sporządzić _drzewo genealogiczne_ tworzonych procesów (z zaznaczonymi identyfikatorami `PID`, `PPID` i `PGID`).

> **Uwaga:** Różne procesy mają różną liczbę dzieci.

#### Dla zainteresowanych:

*   Zmienić nazwę programu `argv[0]` na `"parent"` dla procesu macierzystego oraz `"child"` dla procesu potomnego. Należy przekopiować napisy np. używając funkcji `strncpy()`. Proszę pamiętać aby nie przekroczyć oryginalnej długości argumentu `argv[0]`.
*   Wynik sprawdzić używając komend `ps u` **oraz** `ps -a`. Drzewko wszystkich procesów można zobaczyć komendą `ps -AHF`.

### Zadanie 4. `lider.c`

Zmodyfikować program `procesy.c` tak, aby każdy proces potomny stawał się _liderem_ swojej własnej grupy. Należy użyć `setpgid()`.

Pytania do zestawu
------------------

*   Opisać dokładnie jak działa funkcja `fork()`?
*   Ile powstaje procesów w zadaniu **procesy** i dlaczego?
*   Ile procesów powstanie przy _n_\-krotnym wywołaniu funkcji `fork` i dlaczego?
*   Jak używając funkcji `sleep` i bez odwoływania się do funkcji `wait()` zapewnić aby procesy macierzyste kończyły się dopiero po procesach potomnych.
*   Jaką wartość zwraca `open()`?
*   Jaką wartość zwraca `read()` i `write()`?

Ćwiczenia dodatkowe
-------------------

### Zadanie A1.

Napisać własną funkcję do diagnostyki błędów działającą podobnie do funkcji `perror`, ale dodatkowo wypisującą kod błędu (wartość zmiennej `errno`). Skorzystać z tablicy komunikatów błędów `sys_errlist[]` i sprawdzać czy wartość zmiennej `errno` mieści się w zakresie jej indeksu (użyć zmiennej `sys_nerr`) - patrz `man perror` i `man errno`. Niech ta funkcja umożliwia również wypisywanie diagnostyki błędów do pliku oraz podejmowanie decyzji czy kontynuować proces, czy też go zakończyć. Napisać wersje, tej funkcji, która zamiast bezpośrednio odwoływać się do tablicy `sys errlist[]`, korzysta z funkcji `strerror` (patrz `man strerror`).

Zasady
------

Rozwiązanie zestawu składa się z:

*   Pliku `Makefile` do kompilacji wszystkich programów w zestawie (nie używać celu `run`).
*   Pliku `README` z opisem działania programów i z odpowiedziami na pytania (sugestia: [markdown](https://pl.wikipedia.org/wiki/Markdown)).
*   Plików z kodem źródłowym programów w języku _C_ (standard _C99_, opcja `-std=c99` kompilatora `gcc`).
*   Pliki źródłowe należy spakować do archiwum `.tar.gz` i nazwać swoim nazwiskiem i numerem zestawu, a następnie umieścić na platformie [Pegaz](http://pegaz.uj.edu.pl) ([więcej informacji jak to zrobić](http://th.if.uj.edu.pl/~atg/SO/wprowadzenie.html#jak-wysyłać-programy-na-platformę-pegaz)).
*   Rozwiązania testu na platformie Pegaz.
*   Ustnej **prezentacji** kodu i wyników

* * *

Andrzej Görlich  
`a.goerlich@outlook.com`

1. Opisać dokładnie jak działa funkcja fork()?
Funkcja fork() tworzy proces potomny, który wykonuje program od momentu jego powstania, przejmuje wszystkie wartości zmiennych.
Zwraca -1 w przypadku błędu, 0 w przypadku procesu potomnego, a w przypadku procesu macierzystego: PID procesu potomnego.

2. Ile powstaje procesów w zadaniu procesy i dlaczego?
W zadaniu procesy.c powstanie 8 procesów, ponieważ pętla for wykonuje się 3 razy.

3. Ile procesów powstanie przy n-krotnym wywołaniu funkcji fork i dlaczego?
Przy n-krotnym wywołaniu funkcji fork powstaje 2^n procesów, ponieważ procesy potomne przejmują wartości iteratora pętli swojego procesu macierzystego.

4. Jak używając funkcji sleep i bez odwoływania się do funkcji wait() zapewnić aby procesy macierzyste kończyły się dopiero po procesach potomnych?
Należy użyć funkcji sleep w momencie, kiedy jesteśmy w procesie macierzystym, aby dać czas na wykonanie się procesu potomnego.
W przypadku moich programów będzie to default case instrukcji switch.

5. Jaką wartość zwraca open()?
Funkcja open() zwraca deksryptor pliku, który służy jako identyfikator pliku.

6. Jaką wartość zwraca read() i write()?
Funkcje read() i write() zwracają ilość bajtów jaką udało im się odczytać/zapisać.